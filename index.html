<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> 3D scene </title>

    <link rel="stylesheet" href="style.css">
    <script type="importmap">
        {
          "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
          }
        }
      </script>
    <script type="module">

        import * as THREE from "three";

        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import  HouseMod  from "./js/house-r0.js";
        import "./js/mountain.js";

        // To store the scene graph, and elements usefull to rendering the scene
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,  // NEW
            renderer: null,
            trees: [],
        };

        // HELPER FUNCTIONS

        const helper = {

            initEmptyScene: function (sceneElements) {

                // ************************** //
                // Create the 3D scene
                // ************************** //
                sceneElements.sceneGraph = new THREE.Scene();

                // ************************** //
                // Add camera
                // ************************** //
                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 500);
                sceneElements.camera = camera;
                camera.position.set(10, 8, 16);
                camera.lookAt(3, 0, 0);

                // ************************** //
                // Add ambient light
                // ************************** //
                const ambientLight = new THREE.AmbientLight('rgb(255, 255, 255)', 0.2);
                sceneElements.sceneGraph.add(ambientLight);

                // ***************************** //
                // Add point light souce (with shadows)
                // ***************************** //
                const light_1 = new THREE.PointLight('rgb(255, 255, 255)', 5000);
                light_1.position.set(60, 20, 0);
                light_1.shadow.mapSize.width = 4000;
                light_1.shadow.mapSize.height = 4000;
                light_1.castShadow = true;
                light_1.name = "light 1";
                sceneElements.sceneGraph.add(light_1);




                // *********************************** //
                // Create renderer (with shadow map)
                // *********************************** //
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor('rgb(0, 255, 255)', 1.0);
                renderer.setSize(width, height);

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // **************************************** //
                // Add the rendered image in the HTML DOM
                // **************************************** //
                const htmlElement = document.querySelector("#Tag3DScene");
                htmlElement.appendChild(renderer.domElement);

                // ************************** //
                // Control for the camera
                // ************************** //
                sceneElements.control = new OrbitControls(camera, renderer.domElement);
                sceneElements.control.screenSpacePanning = true;
            },

            render: function (sceneElements) {
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            },
        };

        // FUCNTIONS FOR BUILDING THE SCENE
        function createTree(scaleX=1,scaleY = 1,scaleZ=1) {
            // Creating a model by grouping basic geometries

            // Cylinder centered at the origin
            const cylinderRadius = 0.25;
            const cylinderHeight = 1;
            const cylinderGeometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 32);
            const redMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const cylinder = new THREE.Mesh(cylinderGeometry, redMaterial);
            // Move base of the cylinder to y = 0
            cylinder.position.y = cylinderHeight / 2.0;
            cylinder.castShadow = true;
            cylinder.receiveShadow = true;

            // Cone
            const baseConeRadius = 0.5;
            const coneHeight = 1.5;
            const coneGeometry = new THREE.ConeGeometry(baseConeRadius, coneHeight, 32);
            const greenMaterial = new THREE.MeshPhongMaterial({ color: 0x33cc33 });
            const cone = new THREE.Mesh(coneGeometry, greenMaterial);
            // Move base of the cone to the top of the cylinder
            cone.position.y = cylinderHeight + coneHeight / 2.0;
            cone.castShadow = true;
            cone.receiveShadow = true;

            // Tree
            const tree = new THREE.Group();
            tree.add(cylinder);
            tree.add(cone);
            tree.scale.set(scaleX, scaleY,scaleZ);
            return tree;
        }

        function createRiver(){
            const riverGeometry = new THREE.PlaneGeometry(5, 100);
            const riverMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(0,0,255)', side: THREE.DoubleSide });
            const riverObject = new THREE.Mesh(riverGeometry, riverMaterial);
            riverObject.rotation.x = Math.PI / 2;
            return riverObject
        }
        function createRoad(){
            const roadGeometry = new THREE.PlaneGeometry(60, 5);
            const roadMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(0,0,0)', side: THREE.DoubleSide });
            const roadObject = new THREE.Mesh(roadGeometry, roadMaterial);
            roadObject.rotation.x = Math.PI / 2;
            return roadObject
        }
        function createBridge(){
            const bridgeGeometry = new THREE.BoxGeometry(5.2, 1, 2); // Adjust dimensions as needed
            const bridgeMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            return bridge;
        }
        function createMountain(){
            const coneGeometry = new THREE.ConeGeometry(7, 15, 32);
            const coneMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(139,69,19)' });
            const coneObject = new THREE.Mesh(coneGeometry, coneMaterial);
            coneObject.castShadow = true;
            coneObject.receiveShadow = true;
            return coneObject;
        }

        const scene = {

            // Create and insert in the scene graph the models of the 3D scene

            load3DObjects: function (sceneGraph) {

                // USA ESTE PLANO PARA TESTAR AS SOMBRAS

                const planeGeometry = new THREE.PlaneGeometry(60, 100);
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(0,255,0)', side: THREE.DoubleSide });
                const planeObject = new THREE.Mesh(planeGeometry, planeMaterial);
                planeObject.rotation.x = Math.PI / 2;
                sceneGraph.add(planeObject);

                // Set shadow property
                planeObject.receiveShadow = true;

                /*const planeObject2 = new THREE.Mesh(planeGeometry, planeMaterial);
                planeObject2.rotation.x = Math.PI / 2;
                planeObject2.position.set(0, 3, 0);
                sceneGraph.add(planeObject2);*/

                

                // ************************** //
                // Create the forest
                // ************************** //

                //const trees = []
                
                for(let i = 0;i<100;i++){
                    const tree = createTree();
                    tree.position.set((Math.random() - 0.5) * 60, 0, (Math.random() - 0.5) * 100)
                    sceneElements.sceneGraph.add(tree)
                    sceneElements.trees.push(tree)
                }
                

                // ************************** //
                // Create a cube
                // ************************** //
                // cube center is at (0,0,0)

                const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const cubeObject = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cubeObject.name = "cube";
                cubeObject.position.set(3, 0.25, 0);
                cubeObject.castShadow = true;
                sceneGraph.add(cubeObject);

                // ************************** //
                // Add a house
                // ************************** //
                /*
                const house = createHouse()
                house.position.set(0, 0, -10)
                sceneGraph.add(house)*/

                const house = HouseMod.create()
                house.position.set(-10, 1, -10)
                house.castShadow = true
                house.receiveShadow = true
                house.name = "house"
                sceneGraph.add(house)

                // ************************** //
                // Add a river
                // ************************** //
                const river = createRiver()
                river.position.set(0, 0.004, 0)
                sceneGraph.add(river)

                // ************************** //
                // Add a road
                // ************************** //
                const road = createRoad()
                road.position.set(0, 0.002, 0)
                road.receiveShadow = true
                sceneGraph.add(road)

                //add lines to the road
                const lineGeometry = new THREE.PlaneGeometry(0.1, 2.5);
                const lineMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)', side: THREE.DoubleSide });
                for(let i = 0; i < 5; i++){
                    const line1 = new THREE.Mesh(lineGeometry, lineMaterial);
                    line1.position.set(-25+i*5, 0.003, 0);
                    line1.rotation.x = Math.PI / 2;
                    line1.rotation.z = Math.PI / 2;
                    sceneGraph.add(line1);
                }
                for (let i = 0; i < 5; i++) {
                    const line1 = new THREE.Mesh(lineGeometry, lineMaterial);
                    line1.position.set(5 + i * 5, 0.003, 0);
                    line1.rotation.x = Math.PI / 2;
                    line1.rotation.z = Math.PI / 2;
                    sceneGraph.add(line1);
                }
                

                /*
                // ************************** //
                // Add a bridge
                // ************************** //
                const bridge = createBridge()
                bridge.position.set(0, 0.003, 0)
                bridge.receiveShadow = true
                sceneGraph.add(bridge)
                */

                // ************************** //
                // Add a bridge made by a tree
                // ************************** //
                const treeBridge = createTree(1.5,2.5)
                treeBridge.position.set(-3, 0.3, 0)
                treeBridge.rotation.z = -Math.PI / 2
                treeBridge.receiveShadow = true
                sceneGraph.add(treeBridge)

                // ************************** //
                // Add mountains
                // ************************** //
                const mountain1 = createMountain()
                const mountain2 = createMountain()
                const subMountain2 = createMountain()
                const mountain3 = createMountain()
                sceneGraph.add(mountain1)
                sceneGraph.add(mountain2)
                sceneGraph.add(subMountain2)
                sceneGraph.add(mountain3)

                mountain1.position.set(0, 7.5, -43)
                mountain2.position.set(-23, 7.5, -25)
                subMountain2.position.set(-25, 6, -18)
                subMountain2.scale.set(0.7,0.8, 0.7)
                mountain3.position.set(-23, 7.5, 25)
                mountain1.receiveShadow = true

            }
        };

        // COLLISION DETECTION
        function collision({ element1, element2 }) {
            const element1Right = element1.position.x + 0.5 / 2
            const element1Left = element1.position.x - 0.5 / 2
            //const element1Top = element1.position.y + 0.5 / 2
            //const element1Bottom = element1.position.y - 0.5 / 2
            const element1Front = element1.position.z + 0.5 / 2
            const element1Back = element1.position.z - 0.5 / 2

            const element2Right = element2.position.x + 0.5 / 2
            const element2Left = element2.position.x - 0.5 / 2
            //const element2Top = element2.position.y + 0.5 / 2
            //const element2Bottom = element2.position.y - 0.5 / 2
            const element2Front = element2.position.z + 0.5 / 2
            const element2Back = element2.position.z - 0.5 / 2

            const xCollision = element1Right >= element2Left && element1Left <= element2Right
            //const yCollision = element1Bottom + 0.02 <= element2Top && element1Top >= element2Bottom
            const zCollision = element1Front >= element2Back && element1Back <= element2Front
            return xCollision  && zCollision
        }

        function inRiver(){
            const cube = sceneElements.sceneGraph.getObjectByName("cube");
            const river = sceneElements.sceneGraph.getObjectByName("river");
            const cubeRight = cube.position.x + 0.5 / 2
            const cubeLeft = cube.position.x - 0.5 / 2
            const cubeFront = cube.position.z + 0.5 / 2
            const cubeBack = cube.position.z - 0.5 / 2

            const riverRight = 2.5
            const riverLeft = -2.5

            const xCollision = cubeRight >= riverLeft && cubeLeft <= riverRight
            return xCollision 
        }

        // ANIMATION

        // Displacement values
        var delta = 0.1;
        var dispX = 0.05, dispZ = 0.05;
        var touchGround = false;

        // To keep track of the keyboard - WASD
        var keyD = false, keyA = false, keyS = false, keyW = false, keyQ=false, keySpace = false;
        var toggledCamera=false;
        var step = 0;

        let frames = 0
        let previousCubePosition = new THREE.Vector3()
        function computeFrame(time) {

            // Can extract an object from the scene Graph from its name
            const light_1 = sceneElements.sceneGraph.getObjectByName("light 1");
            // rotate the light around the plane
            light_1.position.x = 60 * Math.cos(step*0.02);
            light_1.position.y = 60 * Math.sin(step*0.02);


            const cube = sceneElements.sceneGraph.getObjectByName("cube");

            // fall from the platform
            if (cube.position.y > 0.25 && cube.position.x < 30.2 && cube.position.x > -30.2) {   //0.25 is half of the cube height
                cube.position.y -= 0.02;  // velocidade de queda
                cube.position.y -= 0.002;  // gravidade
                sceneElements.camera.position.y -= 0.022;
                //sceneElements.control.update();
            }
            else {
                touchGround = true;
            }

            // fall from the platform
            if (cube.position.x > 30.2 || cube.position.x < -30.2 || cube.position.z > 50.2 || cube.position.z < -50.2 || cube.position.y < 0.20) {
                cube.position.y -= 0.02;  // velocidade de queda
                cube.position.y -= 0.002;  // gravidade
                sceneElements.camera.position.y -= 0.022;
                //sceneElements.control.update();

            }
            // if in the river, the cube moves slower and gets pushed back
            if (inRiver() && cube.position.z < 50) {
                cube.position.z += 0.03;
                dispX = 0.03;
                if(toggledCamera){
                    sceneElements.camera.position.z += 0.03;
                }
            }
            else{
                dispX = 0.05;
            }


            if (keyD && cube.position.x < 30) {
                cube.translateX(dispX);
                if(toggledCamera){
                    sceneElements.camera.position.x += dispX;
                    sceneElements.camera.lookAt(cube.position);
                }


                //sceneElements.control.update();

            }
            if (keyW && cube.position.z > -50) {
                cube.translateZ(-dispZ);
                if (toggledCamera) {
                    sceneElements.camera.position.z -= dispZ;
                     sceneElements.camera.lookAt(cube.position);
                }
                //sceneElements.control.update();

            }
            if (keyA && cube.position.x > -30) {
                cube.translateX(-dispX);
                if (toggledCamera) {
                    sceneElements.camera.position.x -= dispX;
                    sceneElements.camera.lookAt(cube.position);
                }
                //sceneElements.camera.position.x -= dispX;

                //sceneElements.control.update();
                //sceneElements.camera.lookAt(cube.position);

            }
            if (keyS && cube.position.z < 50) {
                cube.translateZ(dispZ);
                if (toggledCamera) {
                    sceneElements.camera.position.z += dispZ;
                    sceneElements.camera.lookAt(cube.position);
                }
                //sceneElements.control.update();
            }
            for(const tree of sceneElements.trees){
                // let the trees be pushed by the cube
                if(collision({element1: cube, element2: tree})){
                    /*  // FIRST IDEA
                    const translate = cube.position.clone().sub(tree.position).normalize().multiplyScalar(0.1)
                    cube.position.add(translate)
                    sceneElements.camera.position.add(translate)*/
                    // SECOND IDEA
                    if(tree.position.x > -30 && tree.position.x < 30 && tree.position.z > -50 && tree.position.z < 50){
                        const translate = cube.position.clone().sub(previousCubePosition).normalize().multiplyScalar(0.1)
                        //const translate = new THREE.Vector3(dispX*keyD - dispX*keyA, 0, dispZ*keyS - dispZ*keyW)
                        console.log(previousCubePosition)
                        console.log(cube.position)
                        console.log(translate)
                        tree.position.add(translate)
                    }
                    
                }
                // let the river carry the trees
                if(tree.position.x > -2.5 && tree.position.x < 2.5 && tree.position.z > -50 && tree.position.z < 50){
                    tree.position.z += 0.03;
                }
            }
            

           
            /*
            if (keySpace) {
                if (touchGround) {
                    if (cube.position.y < 1.5) {
                        cube.position.y += 0.1;
                        sceneElements.camera.position.y += 0.1;
                    }
                }
                if (cube.position.y >= 1.5) {
                    touchGround = false;
                }
            }*/

            step += 0.03;
            
            frames++
            previousCubePosition = cube.position.clone()
            //sceneElements.camera.position.set(cube.position.x, cube.position.y + 2, cube.position.z + 5);
            // Rendering
            helper.render(sceneElements);
            //sceneElements.control.update();
            //console.log(sceneElements.camera.position)
            // Animation
            //Call for the next frame
            requestAnimationFrame(computeFrame);
        }

        // Call functions:
        //  1. Initialize the empty scene
        //  2. Add elements within the scene
        //  3. Animate

        function init() {
            helper.initEmptyScene(sceneElements);
            scene.load3DObjects(sceneElements.sceneGraph);
            requestAnimationFrame(computeFrame);
        }

        // HANDLING EVENTS

        // Event Listeners

        window.addEventListener('resize', resizeWindow);

        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);

        // Update render image size and camera aspect when the window is resized
        function resizeWindow(eventParam) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();

            sceneElements.renderer.setSize(width, height);

            // Comment when doing animation
            // computeFrame(sceneElements);
        }

        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = true;
                    break;
                case 83: //s
                    keyS = true;
                    break;
                case 65: //a
                    keyA = true;
                    break;
                case 87: //w
                    keyW = true;
                    break;
                case 81:    //q
                    keyQ = true;
                    toggledCamera = !toggledCamera;
                    if (toggledCamera){
                        console.log("here")
                        const cubePos = sceneElements.sceneGraph.getObjectByName("cube").position;
                        sceneElements.camera.position.set(cubePos.x+3, cubePos.y + 2, cubePos.z + 5);
                        sceneElements.camera.lookAt(cubePos);
                        //erase orbitcontrols
                        sceneElements.control.dispose();
                        sceneElements.controls.enabled = false; // This will prevent the controls from updating

                    } 
                    else {

                        sceneElements.camera.position.set(10, 8, 16);
                        sceneElements.camera.lookAt(0, 0, 0);
                        sceneElements.control = new OrbitControls(sceneElements.camera,sceneElements.renderer.domElement);
                        sceneElements.control.screenSpacePanning = true;

                    }
                    
                    break;
                
                /*
                case 32: //space
                    keySpace = true;
                    break;*/
                
                
            }
        }

        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = false;
                    break;
                case 83: //s
                    keyS = false;
                    break;
                case 65: //a
                    keyA = false;
                    break;
                case 87: //w
                    keyW = false;
                    break;
                case 81:    //q
                    keyQ = false;
                    break;
                /*
                case 32: //space
                    keySpace = false;
                    touchGround = false;    // não permitir double jump só por não chegar á altura máxima
                    break;*/
            }
        }


        // STARTING

        init();

    </script>

</head>

<body>
    <div id="Tag3DScene"> </div>
</body>

</html>